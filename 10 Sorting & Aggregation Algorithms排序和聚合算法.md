# Query Plan
到目前为止，我们已经讨论了访问方法。现在我们需要实际执行查询。 数据库系统将把 SQL 编译成查询计划。查询计划是一棵运算符树。我们将在稍后的查询执行讲座中介绍这一点。 对于面向磁盘的数据库系统，我们将使用缓冲池来实现需要溢出到磁盘的算法。我们希望最小化算法的 I/O。
# Sorting
DBMS 需要对数据进行排序，因为表中的元组在关系模型下没有特定的顺序。排序（可能）用在 ORDER BY、GROUP BY、JOIN 和 DISTINCT 运算符中。如果需要排序的数据适合内存，那么 DBMS 可以使用标准排序算法（例如快速排序）。如果数据不适合，则 DBMS 需要使用外部排序，该排序能够根据需要溢出到磁盘，并且更喜欢顺序 I/O 而不是随机 I/O。
如果查询包含带有 LIMIT 的 ORDER BY，则 DBMS 只需扫描数据一次即可找到前 N 个元素。这称为 Top-N 堆排序。堆排序的理想场景是前 N 个元素适合内存，这样 DBMS 在扫描数据时只需维护内存中排序的优先级队列。
对太大而无法放入内存的数据进行排序的标准算法是外部合并排序。它是一种分而治之的排序算法，将数据集分成单独的运行，然后分别对它们进行排序。它可以根据需要将运行溢出到磁盘，然后一次将其读回。该算法由两个阶段组成： 
阶段#1– 排序：首先，该算法对适合主内存的小数据块进行排序，然后将排序后的页面写回磁盘。
阶段#2 – 合并：然后，该算法将排序后的子文件组合成一个更大的单个文件。
排序运行可以是早期实现的，这意味着值存储在页面中，也可以是后期实现的，我们只在排序运行中存储记录 ID 并稍后读取它们。

## 二路归并
该算法最基本的版本是双向归并排序。该算法在排序阶段读取每个页面，对其进行排序，然后将排序后的版本写回磁盘。然后，在合并阶段，它使用三个缓冲区页。它从磁盘读取两个已排序的页面，并将它们合并到第三个缓冲区页面中。每当第三页填满时，它就会写回磁盘并替换为空页。每组已排序的页面称为一次运行。然后该算法递归地将运行合并在一起。
如果 N 是数据页总数，则算法总共需要 1 + ⌈log2N⌉ 次遍历数据（1 表示第一个排序步骤，然后 ⌈log2N⌉ 表示递归合并）。总 I/O 成本为 2N ×（遍数），因为每次遍对每个页面执行一次 I/O 读取和一次 I/O 写入。

## 通用多路归并归并排序
该算法的通用版本允许 DBMS 充分利用三个以上的缓冲区页。令 B 为可用缓冲区页面的总数。然后，在排序阶段，算法可以一次读取 B 页并将 ⌈ N/B ⌉   排序运行写回磁盘。合并阶段还可以在每次传递中组合最多 B − 1 次运行，再次使用一个缓冲区页来存储组合数据并根据需要写回磁盘。
在广义版本中，算法执行 1 +  ⌈ logB−1 (N /B) ⌉遍（排序阶段 1 次，合并阶段  ⌈ logB−1 (N /B) ⌉。那么，总 I/O 成本为 2N × （遍数）因为它再次必须对每个遍中的每个页面进行读取和写入。

## 双缓冲优化
外部合并排序的一种优化是在后台预取下一次运行，并将其存储在第二个缓冲区中，同时系统正在处理当前运行。通过持续利用磁盘，可以减少每个步骤中 I/O 请求的等待时间。此优化需要使用多个线程，因为预取应该在当前运行的计算发生时发生。

## 比较算法优化
代码专门化通常用于加速排序比较。可以将比较器硬编码为特定的键类型，而不是将比较器作为排序算法的函数指针提供。 C++ 中的模板专门化就是一个例子。另一个优化（对于基于字符串的比较）是后缀截断，其中可以比较长 VARCHAR 键的二进制前缀以进行相等性检查，如果前缀相等，则可以回退到较慢的字符串比较。

## Using B+Trees
有时，DBMS 使用现有的 B+tree 索引来辅助排序比使用外部合并排序算法更有利。特别是，如果索引是聚集索引，则DBMS只需遍历B+树即可。由于索引是聚簇的，数据将以正确的顺序存储，因此 I/O 访问将是顺序的。这意味着它总是比外部合并排序更好，因为不需要计算。另一方面，如果索引是非聚集的，则遍历树几乎总是更糟糕，因为每个记录都可以存储在任何页中，因此几乎所有记录访问都需要磁盘读取。

# Aggregations
查询计划中的聚合运算符将一个或多个元组的值折叠为单个标量值。有两种实现聚合的方法：(1) 排序和 (2) 散列。
## Sorting
DBMS 首先对 GROUP BY 键上的元组进行排序。如果所有内容都适合缓冲池（例如快速排序），它可以使用内存排序算法；如果数据大小超过内存，它可以使用外部合并排序算法。然后，DBMS 对排序后的数据执行顺序扫描以计算聚合。运算符的输出将根据键进行排序。执行排序聚合时，对查询操作进行排序以最大限度地提高效率非常重要。例如，如果查询需要过滤，那么最好先进行过滤，然后对过滤后的数据进行排序，以减少需要排序的数据量
# Hashing
对于计算聚合来说，散列在计算上比排序更高效。 DBMS 在扫描表时填充临时哈希表。对于每条记录，检查哈希表中是否已有条目并执行适当的修改。如果哈希表的大小太大而无法放入内存，则 DBMS 必须将其溢出到磁盘。完成此操作需要两个阶段： 

- 第 1 阶段 – 分区：使用哈希函数 h1 根据目标哈希键将元组拆分为磁盘上的分区。这会将所有匹配的元组放入同一分区中。假设总共有 B 个缓冲区，我们将有 B-1 个用于分区的输出缓冲区和 1 个用于输入数据的缓冲区。如果任何分区已满，DBMS 会将其溢出到磁盘。
- 阶段#2 – ReHash：对于磁盘上的每个分区，将其页面读入内存并基于第二个哈希函数h2（其中h1 不等于 h2）构建内存中哈希表。然后遍历该哈希表的每个存储桶，将匹配的元组聚集在一起以计算聚合。这假设每个分区都适合内存。

在ReHash阶段，DBMS可以存储形式对（GroupByKey→RunningValue）来计算聚合。 RunningValue 的内容取决于聚合函数。要将新元组插入哈希表： 

- 如果找到匹配的GroupByKey，则相应地更新RunningValue。
- 否则插入一个新的(GroupByKey→RunningValue) 对。

一般来说，对于聚合，散列总是更有效，除非数据已经预先排序（例如，遵循 Order By）。
