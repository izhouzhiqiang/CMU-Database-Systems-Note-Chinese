# 存储
我们将重点关注“面向磁盘”的 DBMS 架构，该架构假设数据库的主要存储位置位于非易失性磁盘上。
在存储层次结构的顶部，您拥有最靠近 CPU 的设备。这是最快的存储，但也是最小且最昂贵的。距离 CPU 越远，存储设备就越大，但速度越慢。这些设备的每 GB 价格也变得更便宜。
易失性设备：

-  易失性意味着如果您拔掉机器的电源，数据就会丢失。
-  易失性存储支持通过字节寻址位置进行快速随机访问。这意味着程序可以跳转到任何字节地址并获取那里的数据。
-  就我们的目的而言，我们始终将此存储类别称为“内存”。非易失性设备： • 非易失性意味着存储设备不需要连续供电即可保留其所存储的位。
-  它也是块/页可寻址的。这意味着，为了读取特定偏移处的值，程序首先必须将 4 KB 页加载到保存程序想要读取的值的内存中。
-  传统上，非易失性存储更适合顺序访问（同时读取多个连续的数据块）。
-  我们将其称为“磁盘”。我们不会对固态存储 (SSD) 和旋转硬盘 (HDD) 进行（主要）区分。

还有一类相对较新的存储设备越来越流行，称为持久内存。这些设备被设计为两全其美：几乎与 DRAM 一样快，并且具有磁盘持久性。我们不会在本课程中介绍这些设备，它们目前还没有在生产中广泛使用。最著名的例子可能是 Optane；不幸的是，英特尔将从 2022 年夏季开始逐步减少生产。请注意，您可能会看到较早的将持久内存称为“非易失性内存”的引用。
您可能会看到对 NVMe SSD 的引用，其中 NVMe 代表非易失性内存 Express。这些 NVMe SSD 与持久内存模块不是同一硬件。相反，它们是典型的 NAND 闪存驱动器，通过改进的硬件接口进行连接。这种改进的硬件接口可实现更快的传输，从而利用 NAND 闪存性能的改进。
由于我们的 DBMS 架构假设数据库存储在磁盘上，因此 DBMS 的组件负责确定如何在非易失性磁盘和易失性内存之间移动数据，因为系统无法直接操作磁盘上的数据。

由于从磁盘获取数据的速度非常慢，因此我们将重点关注隐藏磁盘的延迟，而不是使用寄存器和缓存进行优化。如果从 L1 缓存引用读取数据需要一秒钟，那么从 SSD 读取需要 4.4 小时，从 HDD 读取需要 3.3 周。

# 面向磁盘的 DBMS 概述
数据库全部在磁盘上，数据库文件中的数据被组织成页，第一页是目录页。为了对数据进行操作，DBMS 需要将数据放入内存中。它通过一个缓冲池来管理磁盘和内存之间的数据来回移动来实现这一点。 DBMS 还有一个执行查询的执行引擎。执行引擎将向缓冲池请求特定页面，缓冲池将负责将该页面放入内存中，并为执行引擎提供指向内存中该页面的指针。当执行引擎在该部分内存上运行时，缓冲池管理器将确保该页面在那里。

# DBMS vs. OS
DBMS 的高级设计目标是支持超出可用内存量的数据库。
由于读/写磁盘的成本很高，因此必须仔细管理磁盘的使用。我们不希望从磁盘获取某些内容时出现大的停顿，从而减慢其他一切。我们希望 DBMS 在等待从磁盘获取数据时能够处理其他查询。
这种高级设计目标就像虚拟内存一样，其中有很大的地址空间和操作系统从磁盘引入页面的地方。
实现这种虚拟内存的一种方法是使用 mmap 将文件的内容映射到进程的地址空间中，这使得操作系统负责在磁盘和内存之间来回移动页面。
不幸的是，这意味着如果 mmap 遇到页面错误，该进程将被阻塞。

- 如果需要写入，则永远不想在 DBMS 中使用 mmap。
- DBMS（几乎）总是希望自己控制事物，并且可以做得更好，因为它更多地了解正在访问的数据和正在处理的查询。
- 操作系统并不友好。

可以通过以下方式使用操作系统：

   - madvise：告诉操作系统您何时计划阅读某些页面。
   - mlock：告诉操作系统不要将内存范围交换到磁盘。
   - msync：告诉操作系统将内存范围刷新到磁盘。

出于正确性和性能方面的原因，我们不建议在 DBMS 中使用 mmap。
尽管系统将具有看起来像操作系统可以提供的功能，但让 DBMS 本身实现这些过程可以为其提供更好的控制和性能。

# 文件存储
DBMS 最基本的形式是将数据库作为文件存储在磁盘上。有些可能使用文件层次结构，其他可能使用单个文件（例如 SQLite）。
操作系统对这些文件的内容一无所知。只有 DBMS 知道如何解密其内容，因为它是以 DBMS 特定的方式编码的。
DBMS 的存储管理器负责管理数据库的文件。它将文件表示为页面集合。它还跟踪哪些数据已被读取和写入页面以及这些页面中有多少可用空间。

# Database Pages
DBMS 将数据库组织在一个或多个固定大小的数据块（称为页）中的文件中。页面可以包含不同类型的数据（元组、索引等）。大多数系统不会在页面内混合这些类型。有些系统要求页面是独立的，这意味着读取每个页面所需的所有信息都在页面本身上。
每个页面都有一个唯一的标识符。如果数据库是单个文件，则页面 id 可以只是文件偏移量。大多数 DBMS 都有一个间接层，将页面 ID 映射到文件路径和偏移量。系统的上层会要求特定的页码。然后，存储管理器必须将该页号转换为文件和偏移量才能找到该页。
大多数 DBMS 使用固定大小的页面来避免支持可变大小的页面所需的工程开销。例如，对于可变大小的页面，删除页面可能会在文件中产生一个洞，而 DBMS 无法轻松地用新页面填充该洞。
DBMS 中的页有以下三个概念：

- 硬件页（通常为 4 KB）
- 操作系统页面 (4 KB)
- 数据库页（1-16 KB）

存储设备保证硬件页面大小的原子写入。如果硬件页面为 4 KB，并且系统尝试将 4 KB 写入磁盘，则要么全部 4 KB 都将被写入，要么全部都不写入。
这意味着，如果我们的数据库页大于硬件页，DBMS 将必须采取额外措施来确保数据安全写出，因为当系统崩溃时，程序可能会在将数据库页写入磁盘时中途停止。

# Database Heap
有几种方法可以找到 DBMS 想要的页面在磁盘上的位置，堆文件组织就是其中一种方法。堆文件是无序的页面集合，其中元组以随机顺序存储。
DBMS 可以通过使用页面链接列表或页面目录来定位给定页面 ID 的磁盘上的页面。

1. 链表：标头页保存指向空闲页列表和数据页列表的指针。但是，如果 DBMS 正在查找特定页，则它必须对数据页列表进行顺序扫描，直到找到它正在查找的页。
2. 页目录：DBMS 维护特殊页，用于跟踪数据页的位置以及每个页上的可用空间量。

# Page Layout 页面布局
每个页面都包含一个标题，用于记录有关页面内容的元数据： 

- 页面大小。
- 校验和。
- DBMS 版本。
- 事务可见性
- 自我封闭。 （某些系统（例如 Oracle）需要这样做。）

布局数据的一种方法是跟踪 DBMS 在页面中存储了多少元组，然后在每次添加新元组时追加到末尾。但是，当元组被删除或元组具有可变长度属性时，就会出现问题。
在页面中布局数据有两种主要方法：
(1) 分槽页面（slotted-pages）
(2) 日志结构（ log-structured）

slotted-pages：页面将slots映射到偏移量。

- 当今 DBMS 中最常用的方法。
- 标头跟踪已使用的槽的数量、最后使用的槽的起始位置的偏移量以及跟踪每个元组的起始位置的槽数组。
- 添加元组时，槽数组将从头到尾增长，元组的数据从尾到头增长。当槽数组和元组数据相遇时，该页被认为已满。

日志结构：在下一讲中介绍。

# Tuple Layout
元组本质上是字节序列。 DBMS 的工作是将这些字节解释为属性类型和值。
元组标头：包含有关元组的元数据。

- DBMS 并发控制协议的可见性信息（即有关哪个事务创建/修改该元组的信息）。
- NULL 值的位图。
- DBMS 不需要在此处存储有关数据库模式的元数据。

元组数据：属性的实际数据。

- 属性通常按照您在创建表时指定的顺序存储。
- 大多数DBMS 不允许元组超过页的大小。

唯一标识符： • 数据库中的每个元组都分配有一个唯一标识符。

- 最常见：页面id +（偏移量或槽位）。
- 应用程序不能依赖这些ID 来表示任何含义。

非规范化元组数据：如果两个表相关，DBMS 可以“预连接”它们，因此这些表最终位于同一页面上。这使得读取速度更快，因为 DBMS 只需加载一页而不是两个单独的页面。然而，它使得更新成本更高，因为 DBMS 需要为每个元组提供更多空间。

 
