# Joins
良好的数据库设计的目标是最大限度地减少信息重复量。这就是为什么表格是基于归一化理论组成的。因此需要连接来重建原始表。
我们专注于组合两个表的内部等值连接算法。等值连接算法连接键相等的表。可以调整这些算法以支持其他连接。

## Operator Output
对于在连接属性上匹配的元组 r ∈ R 和元组 s ∈ S，连接运算符将 r 和 s 连接在一起形成一个新的输出元组。
实际上，连接运算符生成的输出元组的内容各不相同。它取决于 DBMS 的查询处理模型、存储模型和查询本身。连接运算符输出的内容有多种方法。

- 数据：此方法将外部表和内部表中的属性值复制到元组中，放入专门用于该运算符的中间结果表中。这种方法的优点是查询计划中的未来运算符永远不需要返回基表来获取更多数据。缺点是这需要更多内存来实现整个元组。这称为早期物化。

DBMS 还可以执行额外的计算并省略稍后在查询中不需要的属性，以进一步优化此方法。

- 记录ID：在此方法中，DBMS 仅复制连接键以及匹配元组的记录ID。此方法非常适合列存储，因为 DBMS 不会复制查询不需要的数据。这称为后期物化。

## Cost Analysis
这里用于分析不同连接算法的成本指标是用于计算连接的磁盘 I/O 数量。这包括从磁盘读取数据以及将任何中间数据写入磁盘所产生的 I/O。我们寻求减少基于磁盘的系统中连接的 I/O，忽略计算成本，因为 I/O 成本占主导地位。
请注意，仅考虑计算连接时产生的 I/O，而不考虑输出结果时产生的 I/O。这是因为输出成本取决于数据，而且任何连接算法的输出都是相同的，因此不同算法之间的成本不会改变。


进一步注意，R ▷◁ S（表 R 和 S 的自然连接）是最常见的操作，必须仔细优化。一种低效算法可能涉及计算 R × S（表 R 和 S 的叉积）并选择相关元组。然而，叉积非常大，导致方法效率非常低。
一般来说，在某些情况下会有许多算法/优化可以降低连接成本，但没有一种算法可以在每种情况下都能很好地工作。

# Nested Loop Join
从较高层次来看，这种类型的连接算法由两个嵌套的 for 循环组成，这两个循环遍历两个表中的元组并逐对比较每个元组。如果元组与连接谓词匹配，则输出它们。
外层for循环中的表称为外表，内层for循环中的表称为内表。
DBMS 总是希望使用“较小”的表作为外表。更小的可以是元组数量或页数。 DBMS 还希望在内存中缓冲尽可能多的外表。它还可以尝试利用索引在内表中查找匹配项。
下文中使用的变量： 

- 表 R（外表）中的 M 页，总共 m 个元组 
- 表 S（内表）中的 N 页，总共 n 个元组

## 嵌套循环连接
对于外表中的每个元组，将其与内表中的每个元组进行比较。这是最坏的情况，其中 DBMS 必须对外表中的每个元组进行内表的完整扫描，而无需任何缓存或访问局部性。
成本：M + (m × N)
## 块嵌套循环连接
对于外表中的每个块，从内表中获取每个块并比较这两个块中的所有元组。该算法执行的磁盘访问较少，因为 DBMS 扫描内表中的每个外表块而不是每个元组。
成本：M + ((R 中的块数) × N) 
如果 DBMS 有 B 个缓冲区可用于计算连接，则它可以使用 B − 2 个缓冲区来扫描外表。它将使用一个缓冲区来扫描内表，并使用一个缓冲区来存储连接的输出。
成本：M + (floor(M/(B−2))   × N )
## 索引嵌套循环连接
以前的嵌套循环连接算法性能不佳，因为 DBMS 必须执行顺序扫描来检查内表中的匹配项。但是，如果数据库已经在连接键上有一个表之一的索引，则可以使用该索引来加快比较速度。 DBMS 可以使用现有索引或为连接操作构建临时索引。
外表将是没有索引的表。内表将是带有索引的表。
假设每个索引探针的成本是每个元组的某个常数值 C。
Cost: M + (m × C)

# 排序合并连接
在较高级别上，排序合并联接根据联接键对两个表进行排序。为此，DBMS 可以使用外部归并排序算法。然后，它使用游标遍历每个表并发出匹配项（就像在合并排序中一样）。
如果一个或两个表已根据连接属性（如聚集索引）排序，或者输出无论如何都需要根据连接键排序，则此算法非常有用。
该算法最糟糕的情况是两个表中所有元组的连接属性都包含相同的值，这在实际数据库中不太可能发生。在这种情况下，合并的成本将为 M · N。但大多数时候，键大多是唯一的，因此合并成本约为 M + N。
假设 DBMS 有 B 个缓冲区可用于算法：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/26927011/1715246924066-ecbd8a5e-18e4-4cf6-956a-c1553674f4e9.png#averageHue=%23f7f4f2&clientId=u4d8fad25-fa92-4&from=paste&height=138&id=uaecacacb&originHeight=165&originWidth=603&originalType=binary&ratio=1.1979166269302368&rotation=0&showTitle=false&size=47168&status=done&style=none&taskId=u42350423-51a0-4f69-b61d-be70ba913d5&title=&width=503.37392974103614)
# Hash Join
哈希连接算法的高级思想是使用哈希表根据元组的连接属性将元组分割成更小的块。这减少了 DBMS 为计算连接而需要对每个元组执行的比较次数。散列连接只能用于完整连接键上的等连接。
如果元组 r ∈ R 和元组 s ∈ S 满足连接条件，则它们具有相同的连接属性值。如果该值被哈希为某个值 i，则 R 元组必须位于存储桶 ri 中，而 S 元组必须位于存储桶 si 中。因此，桶ri中的R元组只需与桶si中的S元组进行比较。

## 基本哈希连接 

- 第 1 阶段 – 构建：首先，扫描外部关系并使用连接属性上的哈希函数 h1 填充哈希表。哈希表中的关键是连接属性。该值取决于实现（可以是完整元组值或元组 ID）。
- 阶段#2 – 探测：扫描内部关系并在每个元组的连接属性上使用哈希函数h1 跳转到哈希表中的相应位置并找到匹配的元组。由于哈希表中可能存在冲突，因此 DBMS 需要检查连接属性的原始值以确定元组是否真正匹配。

如果 DBMS 知道外表的大小，则连接可以使用静态哈希表。如果它不知道大小，则连接必须使用动态哈希表或允许溢出页。
探测阶段的一项优化是使用布隆过滤器。这是一个概率数据结构，可以放入CPU缓存并回答问题：哈希表中的键x是吗？要么肯定不，要么可能是。它通过防止不会导致匹配的磁盘读取来减少磁盘 I/O 量。

#### 补充：Bloom Filter 布隆过滤器
## Grace Hash Join / Partitioned Hash Join
当主存无法容纳表时，DBMS 必须随机地换入和换出表，这会导致性能不佳。 Grace Hash Join 是基本哈希联接的扩展，它还将内表哈希到写入磁盘的分区中。

- 阶段#1 – 构建：首先，扫描外部表和内部表，并使用连接属性上的哈希函数h1 填充哈希表。哈希表的存储桶根据需要写入磁盘。如果单个桶装不下内存，DBMS 可以使用不同哈希函数 h2（其中 h1 != h2）的递归分区来进一步划分桶。这可以递归地继续，直到桶适合内存。
- 阶段#2 – 探测：对于每个存储桶级别，检索外部表和内部表的相应页面。然后，对这两个页面中的元组执行嵌套循环连接。这些页面将适合内存，因此此连接操作会很快

一个有 N 页的表需要大约 √ N 个缓冲区。上述方法在阶段 #1 中创建了 B − 1 个大小最多为 B −2 块的溢出分区，因此假设哈希函数均匀分布记录，则可以使用此方法进行哈希的最大表为 (B −1)·( B -2) 缓冲器。如果哈希函数不均匀，可以引入模糊因子f > 1，因此最大的表是B·√f·N。
 	
Partitioning Phase Cost: 2 × (M + N)
Probe Phase Cost: (M + N)
Total Cost: 3 × (M + N)

混合哈希连接优化：在基本哈希连接和格雷斯哈希连接之间进行适配；如果键倾斜，请将热分区保留在内存中并立即执行比较，而不是将其溢出到磁盘。
很难正确实施。

# Conclusion
连接是与关系数据库交互的重要组成部分，因此确保 DBMS 具有执行连接的有效算法至关重要。

 ![image.png](https://cdn.nlark.com/yuque/0/2024/png/26927011/1715306843978-66cf0c69-4f85-472e-9605-88bc09398e59.png#averageHue=%23f3f0ee&clientId=uddce7a74-d67f-4&from=paste&height=279&id=u309d67a3&originHeight=334&originWidth=862&originalType=binary&ratio=1.1979166269302368&rotation=0&showTitle=false&size=132494&status=done&style=none&taskId=u933c62cd-617b-49bc-a7de-c362abace0a&title=&width=719.5826325651295)
哈希连接几乎总是比基于排序的连接算法更好，但在某些情况下，基于排序的连接会更好。这包括对非统一数据的查询、当数据已经在连接键上排序时以及当结果需要排序时。好的 DBMS 将使用其中之一或两者。

 
 
