# Crash Recovery 崩溃恢复
恢复算法是在出现故障时确保数据库一致性、事务原子性和持久性的技术。当发生崩溃时，内存中尚未提交到磁盘的所有数据都有丢失的风险。恢复算法的作用是防止系统崩溃后信息的丢失。
每个恢复算法有两个部分:

- 正常事务处理期间的动作，以确保DBMS可以从故障中恢复。
- 将数据库恢复到确保原子性、一致性和持久性的状态失败后的操作。

恢复算法中使用的关键原语是UNDO和REDO。并非所有算法都使用这两种原语。

- UNDO:删除不完整或终止的事务影响的过程。
- REDO:重新应用已提交事务的持久效果的过程。
# Storage Types存储类型

- 易失性存储-丢失电源或程序退出后，数据不会持续存在。例如:DRAM、SRAM、。
- 非易失性存储-丢失电源或程序存在后数据仍然存在。例如:HDD、SDD。
- 稳定存储-一种不存在的非易失性存储形式，可以在所有可能的故障场景中幸存下来。使用多个存储设备进行近似。
# Intuition for Crash Recovery崩溃恢复的直觉
DBMS使用易失性存储来存储缓冲池页面的内容，因为与非易失性存储相比，易失性存储的读/写速度要快得多。然而，DBMS希望存储持久状态，因此出于性能原因，我们在BPM中允许脏缓冲池页面，并在必要时刷新到非易失性存储。然而，这提出了一个问题:DBMS如何处理易失性存储故障?
# Failure Classification 故障分类
由于DBMS根据底层存储设备划分为不同的组件，因此DBMS需要处理许多不同类型的故障。其中一些故障是可恢复的，而另一些则不可恢复。
类型#1:事务失败
事务失败发生在事务发生错误时，必须中止事务。可能导致事务失败的两种类型的错误是逻辑错误和内部状态错误。

- 逻辑错误:由于某些内部错误条件(例如，完整性，约束违反)，事务无法完成。
- 内部状态错误:由于错误情况(如死锁)，DBMS必须终止正在进行的事务。

类型#2:系统故障
系统故障是承载DBMS的底层软件或硬件的意外故障。在崩溃恢复协议中必须考虑到这些故障。

- 软件故障:DBMS实现出现问题(例如，未捕获的除零异常)，系统不得不停止运行。
- 硬件故障:承载DBMS的计算机崩溃(例如，电源插头被拔掉)。我们假设非易失性存储内容不会因系统崩溃而损坏。这被称为“Failstop”假设，并简化了流程恢复。

类型#3:存储介质故障存储
介质故障是物理存储设备损坏时发生的不可修复的故障。当存储介质发生故障时，DBMS必须从存档版本恢复。DBMS不能从存储故障中恢复，需要人工干预。

- 不可修复的硬件故障:磁头崩溃或类似的磁盘故障破坏全部或部分非易失性存储。破坏被认为是可以检测到的。

# Buffer Pool Management Policies 缓冲池管理策略
DBMS需要确保以下保证:

- 任何事务的更改都是持久的，一旦DBMS告诉某人它已提交。
- 如果事务终止，则没有持久的部分更改。

STEAL策略指示DBMS是否允许未提交的事务覆盖非易失性存储中对象的最新提交值(事务可以将属于不同事务的未提交更改写入磁盘吗?)

- STEAL:允许
- NO-STEAL:不允许。

FORCE策略规定了DBMS是否要求在允许事务提交之前，事务所做的所有更新都反映在非易失性存储上。将提交消息返回给客户端)。

- FORCE:是必需的
- NO-FORCE:不是必需的强制写使恢复更容易，因为所有的更改都被保留，但导致运行时性能差。

最容易实现的缓冲池管理策略称为NO-STEAL + FORCE。在此策略中，DBMS永远不必撤销因未将更改写入磁盘而终止的事务的更改。
它也不必重做已提交事务的更改，因为所有更改都保证在提交时写入磁盘。图1显示了NO-STEAL + FORCE的一个示例。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/26927011/1715356310608-aa09b823-98fe-4d50-bd89-0142f267b928.png#averageHue=%23f8f6f3&clientId=u8e2db32a-4b75-4&from=paste&height=406&id=u428941d9&originHeight=508&originWidth=632&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=124282&status=done&style=none&taskId=ufde94f85-f3b0-4278-9615-16d71d35b4e&title=&width=505.6)
NO STEAL + FORCE的一个限制是所有的数据(即:事务需要修改的写集必须适合内存。否则，该事务将无法执行，因为DBMS不允许在事务提交之前将脏页写入磁盘。
# 
Shadow Paging影子分页
影子分页是对前一个方案的改进，在该方案中，DBMS在写时复制页面以维护两个独立的数据库版本:

- master:仅包含来自提交的txns的更改。
- shadow:包含未提交事务更改的临时数据库。

仅在影子副本中进行更新。当事务提交时，影子副本将自动切换为新的主副本。老主人最终被垃圾收集。这是一个NO-STEAL + FORCE系统的例子。图2显示了影子分页的一个高级示例。
## ![image.png](https://cdn.nlark.com/yuque/0/2024/png/26927011/1715356411848-58bcf250-aac1-4156-b967-fe1d47d2d98a.png#averageHue=%23f5f3f2&clientId=u8e2db32a-4b75-4&from=paste&height=381&id=uf230eb64&originHeight=476&originWidth=649&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=104783&status=done&style=none&taskId=ud8224ff1-5421-47d4-886a-1a6054fd1ff&title=&width=519.2)
Implementation
DBMS以树状结构组织数据库页面，其中根是单个磁盘页面。树有两个副本，主树和影子树。根目录总是指向当前的主副本。当事务执行时，它只对影子副本进行更改。
当一个事务想要提交时，DBMS必须安装它的更新。为此，它只覆盖根目录，使其指向数据库的影子副本，从而交换主目录和影子目录。
在覆盖根目录之前，所有事务更新都不是驻留在磁盘上的数据库的一部分。覆盖根目录后，所有事务的更新都是磁盘驻留数据库的一部分。这种对根的覆盖可以自动完成。
## 恢复

- UNDO:删除影子页。保留主和DB根指针。
- REDO:根本不需要。
## 缺点
影子分页的一个缺点是复制整个页表的成本很高。实际上，只需要复制树中通向更新的叶节点的路径，而不是复制整个树。此外，影子分页的提交开销很高。提交需要刷新页表、根页和每个更新过的页。这种方法会导致对随机非连续页面的大量写操作。此外，这种方法会导致数据碎片，因为可能相关的数据被划分在不同的页面之间。
它还需要垃圾收集，因为当数据更新时，对不同页面的引用将失效，并且需要更新这些引用，以便没有页面引用旧的、未更新的数据。另一个问题是，它一次只支持一个写器事务或批处理事务。
# Journal File日志文件
当事务修改页面时，DBMS在覆盖主版本之前将原始页面复制到单独的日志文件中。重新启动后，如果存在日志文件，那么DBMS将恢复它以撤销未提交事务的更改。
该技术在2010年之前在SQLite中实现。然而，在2010年之后，他们改变了他们的实现方式，转而跟踪预写日志。
# Write-Ahead Logging 预写式日志
使用预写日志记录，DBMS在对磁盘页面进行更改之前，将对数据库所做的所有更改记录在一个日志文件中(在稳定的存储上)。日志包含足够的信息来执行必要的撤消和重做操作，以便在崩溃后恢复数据库。在将数据库对象刷新到磁盘之前，DBMS必须将对应于对数据库对象所做更改的日志文件记录写入磁盘。
图3显示了WAL的一个示例。WAL是一个偷窃+无强制系统的例子。
在影子分页中，DBMS需要对磁盘上的随机非连续页面执行写操作。
预写日志允许DBMS将随机写转换为顺序写以优化性能。因此，几乎每个DBMS都使用预写日志(write-ahead logging, WAL)，因为它具有最快的运行时性能。但是使用WAL的DBMS的恢复时间比影子分页要慢，因为它必须重放日志。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/26927011/1715356587027-699124df-d285-4ce4-a91a-13688b53a68e.png#averageHue=%23faf9f7&clientId=u8e2db32a-4b75-4&from=paste&height=365&id=uef4ecbe8&originHeight=456&originWidth=638&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=77413&status=done&style=none&taskId=u4cdd3723-a3e5-4c24-a794-22590803ecf&title=&width=510.4)
## 实现
DBMS首先将所有事务的日志记录存储在易失性存储器中。然后，在允许在非易失性存储中覆盖页面本身之前，将与已更新页面相关的所有日志记录写到非易失性存储中。直到将事务的所有日志记录写入稳定的存储中，才认为事务已提交
当事务开始时，为每个事务写入一个<BEGIN>到日志中，以标记其起始点。
当事务完成时，将<COMMIT>写入日志，并确保在向应用程序返回确认之前刷新所有日志记录。
每个日志条目包含回退或重放对单个对象的更改所需的信息:

- Transaction ID.
- Object ID.
- Before Value (used for UNDO).
- After Value (used for REDO).

DBMS必须将事务的所有日志条目刷新到磁盘，然后才能告诉外界事务已成功提交。系统可以使用“组提交”优化来批量处理多个日志刷新，以分摊开销。刷新要么发生在日志缓冲区已满，要么发生在连续刷新之间间隔了足够的时间。DBMS可以随时将脏页写入磁盘，只要它是在刷新相应的日志记录之后。
## 日志结构系统
在日志结构的DBMS中，事务的日志记录被写入称为MemTable的内存缓冲区。当此缓冲区已满时，将其刷新到磁盘。这种方法仍然需要一个不同的预写日志。这是由于WAL的刷新通常比MemTable的刷新更频繁，并且WAL可能包含未提交的事务。WAL用于在从崩溃中恢复时重新创建内存中的MemTable。

# Logging Schemes日志方案
日志记录的内容可能因实现而异。
## 物理日志:

- 记录对数据库中特定位置所做的字节级更改。
- 示例:git diff
## 逻辑日志:•记录事务执行的高级操作。

- 不一定局限于一页。
- 每条日志记录比物理日志记录需要更少的数据，因为每条记录可以在多个页面上更新多个元组。然而，在不确定的并发控制方案中，当存在并发事务时，很难使用逻辑日志实现恢复。此外，恢复需要更长的时间，因为必须重新执行每个事务。
- 示例:由事务调用的UPDATE、DELETE和INSERT查询。
## 物理逻辑日志:

- 混合方法，日志记录的目标是单个页面，但不指定页面的数据组织。也就是说，根据页面中的槽号标识元组，而不指定更改在页面中的确切位置。因此，DBMS可以在日志记录被写入磁盘后重新组织页面。
- dbms中最常用的方法。

# Checkpoints
基于wal的DBMS的主要问题是日志文件将永远增长。在崩溃之后，DBMS必须重播整个日志，如果日志文件很大，这可能需要很长时间。因此，DBMS可以定期采取检查点，将所有缓冲区刷新到磁盘。
DBMS应该多久执行一次检查点取决于应用程序的性能和停机时间需求。过于频繁地使用检查点会导致DBMS的运行时性能下降。但是在检查点之间等待很长时间可能同样糟糕，因为系统重新启动后的恢复时间会增加。

阻塞检查点实现:

- DBMS停止接受新的事务并等待所有活动事务完成。
- 将当前驻留在主存中的所有日志记录和脏块刷新到稳定存储。
- 写入一个<CHECKPOINT>到日志并刷新到稳定存储。


 
 
 
