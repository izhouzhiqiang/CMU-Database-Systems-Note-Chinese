# 数据库工作负载
## OLTP:Online Transaction Processing
工作负载的特点是快速、短时间运行的操作、重复操作和一次对单个实体进行操作的简单查询。OLTP工作负载通常处理的写操作多于读操作，并且每次只读取/更新少量数据。
OLTP工作负载的一个示例是Amazon店面。用户可以向购物车中添加东西并进行购买，但这些操作只会影响他们的帐户
## OLAP: Online Analytical Processing
OLAP工作负载的特点是对数据库的大部分进行长时间运行、复杂的查询和读取。在OLAP工作负载中，数据库系统经常从OLTP端收集的现有数据中分析和派生新数据。
OLAP工作负载的一个例子是，亚马逊在下雨的一天计算匹兹堡购买最多的商品。

## HTAP: Hybrid Transaction + Analytical Processing
HTAP:混合事务+分析处理一种新的工作负载类型(最近很流行)是HTAP，其中OLTP和OLAP工作负载一起出现在同一个数据库上。

# 存储模型
在页面中存储元组有不同的方法。到目前为止，我们已经假设了n元存储模型。
## n元存储模型，行存 N-Ary Storage Model (NSM)
在n-ary存储模型中，DBMS将单个元组的所有属性连续存储在单个页面中。这种方法非常适合OLTP工作负载，其中请求是大量插入的，事务往往只操作单个实体。这是理想的，因为它只需要一次获取就可以获得单个元组的所有属性
优点:

- 快速插入、更新和删除。
- 适用于需要整个元组的查询。

缺点:

- 扫描表的大部分和/或属性的子集效率低下。
## 分解存储模型，列存Decomposition Storage Model (DSM)
在分解存储模型中，DBMS在数据块中连续地为所有元组存储单个属性(列)。因此，它也被称为“列存储”。此模型非常适合具有许多只读查询的OLAP工作负载，这些只读查询对表的属性子集执行大量扫描。
优点:

- 减少了I/O的浪费，因为DBMS只读取查询所需的数据。
- 更好的查询处理，因为增加了局部性和缓存数据重用。
- 更好的数据压缩。

缺点:

- 由于元组分割/拼接，点查询、插入、更新和删除速度很慢。

在使用列存储时，要将元组放回一起，有两种常见的方法:最常用的方法是固定长度的偏移量。在这里，给定列中的值将与位于相同偏移量的另一列中的值属于同一元组。因此，列中的每个值必须具有相同的长度。
一种不太常见的方法是使用嵌入式元组id。在这里，对于列中的每个属性，DBMS存储一个元组id(例如:主键)。然后，系统还将存储一个映射，以告诉它如何跳转到具有该id的每个属性。注意，这个方法有很大的存储开销，因为它需要为每个属性条目存储一个元组id。

## 跨分区属性 Partition Attributes Across (PAX)
在混合分区属性跨存储模型中，DBMS在数据库页面内垂直分区属性。这样做的目的是在保留行存储的空间局部性优势的同时，获得在列存储上更快处理的好处。
在PAX中，行被水平划分为行组。在每个行组中，属性垂直划分为列。每个行组都类似于其行子集的列存储。
PAX文件有一个全局标头，其中包含一个目录，该目录具有文件行组的偏移量，每个行组维护自己的标头，其中包含有关其内容的元数据。

## 数据库压缩


压缩在基于磁盘的dbms中被广泛使用，因为磁盘I/O(几乎)总是主要的瓶颈。它在具有只读分析工作负载的系统中特别流行。如果元组事先被压缩过，那么DBMS可以获取更多有用的元组，但代价是压缩和解压缩的计算开销更大。
内存中的dbms更复杂，因为它们不必从磁盘获取数据来执行查询。内存比磁盘快得多，但是压缩数据库可以减少对DRAM的需求和处理。他们必须在速度和压缩比之间取得平衡。压缩数据库可以减少对DRAM的需求。它可以降低查询执行期间的CPU成本。
如果数据集完全是随机的，就没有办法进行压缩。然而，现实世界的数据集有一些关键属性是适合压缩的:

- 属性值的高度倾斜分布(例如，Brown语料库的Zipfian分布)。
- 同一元组的属性之间的高度相关性(例如，邮政编码到城市，订单日期到发货日期)。

鉴于此，我们希望数据库压缩方案具有以下属性:

- 必须生成固定长度的值。唯一的例外是存储在单独池中的可变长度数据。这是因为DBMS应该遵循单词对齐，并且能够使用偏移量访问数据。
- 允许DBMS在查询执行期间尽可能延迟解压缩(延迟物化)。
- 必须是无损方案，因为人们不喜欢丢失数据。任何类型的有损压缩都必须在应用程序级别执行。
 
## 压缩的粒度
我们想要压缩的数据类型极大地影响了可以使用的压缩方案。压缩粒度有四种级别:

- 块级别:压缩同一个表的元组块。
- 元组级别:压缩整个元组的内容(仅限NSM)。
- 属性级别:压缩一个元组中的单个属性值。可以针对同一元组的多个属性。
- Columnar Level:压缩存储在多个元组中的一个或多个属性的多个值(仅限列存)。这允许更复杂的压缩方案。

# Naive Compression
DBMS使用通用算法压缩数据(例如，gzip, LZO, LZ4, Snappy, Brotli, Oracle OZIP, Zstd)。尽管DBMS可以使用几种压缩算法，但工程师通常会选择提供较低压缩比的算法，以换取更快的压缩/解压缩。
使用朴素压缩的一个例子是MySQL InnoDB。DBMS压缩磁盘页面，将它们填充到2kb的幂次方数，并将它们存储到缓冲池中。但是，每次DBMS试图读取/修改数据时，必须首先对缓冲池中的压缩数据进行解压缩。
由于访问数据需要对压缩数据进行解压缩，这限制了压缩方案的范围。如果目标是将整个表压缩成一个巨大的块，那么使用朴素的压缩方案是不可能的，因为每次访问都需要压缩/解压缩整个表。因此，由于压缩范围有限，MySQL将表分解为更小的块。
另一个问题是，这些幼稚的方案也不考虑数据的高级含义或语义。该算法不关心数据的结构，也不关心查询计划如何访问数据。因此，这消除了利用延迟物化的机会，因为DBMS无法判断何时可以延迟数据的解压缩。

## Columnar Compression列存压缩
## Run-Length Encoding 运行长度编码(RLE)
RLE将单列中相同值的运行(连续实例)压缩为三元组:

- 属性的值
- 列段中的起始位置
- 运行中元素的数量

DBMS应该事先对列进行智能排序，以最大化压缩机会。这将聚集重复的属性，从而提高压缩比。注意，RLE的有效性在很大程度上取决于底层数据特征(例如，每个数据中属性的数量和频率)。
```
true,true,true,false,false
==>
<true,1,3> <false,4,5>
```
## Bit-Packing编码

 当一个属性的所有值都小于该值声明的最大大小时，使用更少的位来存储它们。
## Mostly Encoding
Bit-Packing变体，它使用一个特殊的标记来指示值何时超过最大大小，然后维护一个查询表来存储它们。
## Bitmap Encoding
DBMS为特定属性的每个唯一值存储单独的位图，其中向量中的偏移量对应于元组。位图中的第i个位置对应于表中的第i个元组，该元组表示该值是否存在。位图通常被分割成块，以避免分配大块的连续内存。
这种方法只适用于值基数较低的情况，因为位图的大小与属性值的基数成线性比例。如果值的基数较大，则位图可能比原始数据集更大。
## Delta Encoding
不要存储精确的值，而是在同一列中记录相邻值之间的差异。基值可以内联存储或存储在单独的查询表中。我们还可以对存储的增量使用RLE来获得更好的压缩比。
## Incremental Encoding
这是一种增量编码，其中记录了常见的前缀或后缀及其长度，因此它们不需要重复。这对于排序过的数据最有效
## Dictionary Compression
最常见的数据库压缩方案是字典编码。DBMS用更小的编码替换值中的频繁出现的值。然后，它只存储这些代码和一个数据结构(即字典)，将这些代码映射到它们的原始值。字典压缩方案需要支持快速编码/解码，以及范围查询。
### 编码和解码:
字典需要决定如何对数据进行编码(将未压缩的值转换为压缩后的形式)和解码(将压缩后的值转换回原始形式)。因此，不可能使用哈希函数。
编码后的值还需要支持与原始值相同的排序顺序(即保持顺序的编码)。这确保在压缩数据上运行的压缩查询返回的结果与在原始数据上运行的未压缩查询一致。此保持顺序属性允许直接对代码执行操作。

注意:列压缩模式最适合读取繁重的工作负载，并且可能需要额外的写支持。

 
