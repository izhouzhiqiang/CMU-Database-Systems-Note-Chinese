# Timestamp Ordering Concurrency Control
时间戳排序(T/O)是一类乐观的并发控制协议，其中DBMS假定事务冲突很少。在允许事务读/写数据库对象之前，DBMS不要求事务获得锁，而是使用时间戳来确定事务的可序列化顺序。
每个事务Ti被分配一个唯一的、单调递增的固定时间戳TS(Ti)。不同的方案在事务期间的不同时间分配时间戳。一些高级方案甚至为每个事务分配多个时间戳。
如果TS(Ti) < TS(Tj)，那么DBMS必须确保执行调度与串行调度相同，其中Ti出现在Tj之前。
有多种时间戳分配实现策略。DBMS可以使用系统时钟作为时间戳，但是在一些极端情况下，比如夏令时，问题就出现了。另一种选择是使用逻辑计数器。然而，这在溢出和跨多台机器的分布式系统维护计数器方面存在问题。也有混合方法，将两种方法结合使用。
# Basic Timestamp Ordering (BASIC T/O)基本时间戳排序(Basic T/O)
基本时间戳排序协议(basic T/O)允许在不使用锁的情况下对数据库对象进行读写。相反，每个数据库对象X都被标记为成功地对该对象执行读(表示为R-TS(X))或写(表示为W-TS(X))的最后事务的时间戳。DBMS然后为每个操作检查这些时间戳。如果一个事务试图以违反时间戳顺序的方式访问一个对象，那么该事务将被中止并重新启动。潜在的假设是，违规将是罕见的，因此这些重启也将是罕见的。
## Read Operations
对于读操作，如果TS(Ti) < W-TS(X)，这违反了Ti相对于X的前写入者的时间戳顺序(不想读取“未来”写入的内容)。因此，Ti被中止，并使用新的时间戳重新启动。否则，读取是有效的，并且允许Ti读取X。DBMS然后将R-TS(X)更新为R-TS(X)和TS(Ti)的最大值。它还必须在私有工作区中创建X的本地副本，以确保Ti的可重复读取。
## Write Operations
对于写操作，如果TS(Ti) < R-TS(X)或TS(Ti) < W-TS(X)，则必须重新启动Ti(不希望覆盖“未来”更改)。否则，DBMS允许Ti写入X并更新W-TS(X)。同样，它需要生成X的本地副本，以确保Ti的可重复读取。
## Optimization: Thomas Write Rule
对于写操作的优化是，如果TS(Ti) < W-TS(X)， DBMS可以忽略写操作并允许事务继续，而不是中止并重新启动它。这被称为托马斯写作规则。注意，这违反了Ti的时间戳顺序，但这是可以接受的，因为没有其他事务会读取Ti对对象X的写入。如果事务Ti在对象X上有后续读取，它可以读取自己的X本地副本。
如果基本T/O协议不使用Thomas写规则，它会生成一个可冲突序列化的调度。它不能有死锁，因为没有事务等待。但是，长时间运行的事务更有可能饿死，因为它们更有可能从较新的事务中读取对象。
它还允许不可恢复的调度。如果事务只有在它们读取其更改的所有事务提交之后才提交，那么调度是可恢复的。否则，DBMS不能保证事务读取将在从崩溃中恢复后恢复的数据。
## 潜在的问题:

- 每次读一个对象都需要一次时间戳写。
- 从复制数据到事务工作区和更新时间戳的高开销。
- 长时间运行的事务可能会饿死。
- 在高并发系统上遭受时间戳分配瓶颈。
- 允许不可恢复的时间表。

# Optimistic Concurrency Control (OCC)乐观并发控制(OCC)
乐观并发控制(OCC)是另一种乐观并发控制协议，它也使用时间戳来验证事务。OCC在冲突数量较低时效果最好。当所有事务都是只读的，或者事务访问不相交的数据子集时，就会出现这种情况。如果数据库很大，并且工作负载没有倾斜，那么冲突的可能性就很低，因此OCC是一个很好的选择。
在OCC中，DBMS为每个事务创建一个私有工作区。事务的所有修改都应用于此工作区。读取的任何对象都被复制到工作空间，写入的任何对象都被复制到工作空间并在那里进行修改。任何其他事务都不能读取其私有工作区中另一个事务所做的更改。
当事务提交时，DBMS比较事务的工作空间写集，以查看它是否与其他事务冲突。如果没有冲突，则将写集安装到“全局”数据库中。
OCC包括三个阶段:

1.  读阶段:在这里，DBMS跟踪事务的读/写集，并将它们的写操作存储在一个私有工作区中。 
2.  验证阶段:当事务提交时，DBMS检查它是否与其他事务冲突。 
3.  写阶段:如果验证成功，DBMS将私有工作区的更改应用到数据库。否则，它将中止并重新启动事务。 
## Validation Phase验证阶段
DBMS在事务进入验证阶段时为其分配时间戳。为了确保只允许可序列化的调度，DBMS检查Ti与其他事务的RW和WW冲突，并确保所有冲突都是单向的

- 方法1:向后验证(从较老的事务到较老的事务)
- 方法2:向前验证(从较老的事务到较年轻的事务)

这里我们将描述前向验证是如何工作的。DBMS检查提交事务与所有其他正在运行的事务的时间戳顺序。尚未进入验证阶段的事务被分配一个时间戳为∞。
如果TS(Ti) < TS(Tj)，则下列三个条件之一必须成立:在Tj开始执行之前，Ti完成了所有三个阶段(串行排序)。

2. Ti在Tj开始其Write阶段之前完成，并且Ti不写入Tj读取的任何对象。
   1. WriteSet(Ti)∩ReadSet(Tj) =∅。
3. Ti在Tj完成其Read阶段之前完成其Read阶段，并且Ti不会对Tj正在读取或写入的任何对象进行写入
   1. WriteSet(Ti)∩ReadSet(Tj) =∅，WriteSet(Ti)∩WriteSet(Tj) =∅。
## 潜在问题:

- 将本地数据复制到事务的私有工作区的开销很高。
- 验证/写入阶段瓶颈。
- 中止可能比其他协议更浪费，因为它们只发生在事务已经执行之后。
- 遭受时间戳分配瓶颈。
# Dynamic Databases and The Phantom Problem动态数据库和幻读问题
在前面的讨论中，我们考虑了对数据库内的一组静态对象进行操作的事务。然而，当事务执行插入、更新和删除时，我们会遇到一组新的复杂情况。
当事务只锁定现有记录，而忽略正在创建过程中的记录时，就会出现幻像问题。这种疏忽可能导致执行不可序列化，因为数据库中的对象集不是固定的。
## 解决幻读问题的方法:

1.  重新执行扫描:事务可能会在提交时重新运行查询，以检查不同的结果，指示由于新记录或删除记录而错过的更改。 
2.  谓词锁定:这涉及到基于查询的谓词获取锁，确保满足谓词的任何数据都不能被其他事务修改。 
3.  索引锁定:利用索引键来保护数据范围，通过确保没有新数据落在锁定范围内来防止幽灵。 
## 重新执行扫描:
DBMS跟踪事务执行的所有查询的WHERE子句。在提交时，它重新执行扫描以确保结果保持一致。
## 谓词锁定:
最初在System R中提出，该方案没有被广泛实现。然而，像HyPer这样的系统利用了一种类似于谓词锁定的精确锁定形式。
## 索引锁定方案:
采用不同的方案来防止使用索引锁定的幻像:

- 键值锁:对索引中的单个键值进行锁，包括不存在值的虚拟键。
- 间隙锁:锁定键值后面的间隙，防止在这些间隙中插入。
- key - range Locks:对一系列密钥进行锁定，从一个现有的密钥到下一个。
- 分层锁:允许事务以不同的模式持有更宽的键范围锁，减少锁管理器开销。

在没有合适的索引的情况下，事务必须锁定表中的每个页或整个表本身，以防止可能导致幽灵的更改。

# Isolation Levels 隔离级别
可序列化性很有用，因为它允许程序员忽略并发性问题，但强制执行它可能会导致并行性过低并限制性能。我们可能希望使用较弱的一致性级别来提高可伸缩性。
隔离级别控制事务暴露给其他并发事务操作的程度。
## 异常现象：

- Dirty Read:读取未提交的数据。
- Unrepeatable Reads:重读会得到不同的结果。
- 幻取:插入或删除导致相同范围扫描查询的不同结果。
## 隔离级别(从最强到最弱):

1. SERIALIZABLE:没有幻影，所有读取都是可重复的，没有脏读取。
   - 可能实现:索引锁+严格2PL。
2. 可重复读取:幽灵可能会发生。
   - 可能实施:严格的2PL。
3. READ-COMMITTED:可能会出现幻象和不可重复的读取。
   - 可能实现:对排他锁实行严格的2PL，读取后立即释放共享锁。
4. READ-UNCOMMITTED:所有异常都可能发生。
   - 可能的实现:对排他锁实行严格的2PL，对读不实行共享锁。

作为SQL-92标准的一部分定义的隔离级别只关注可能发生在基于2pl的DBMS中的异常情况。还有两个额外的隔离级别:

1. 在可重复读和已提交读之间。
   - 防止丢失的更新异常。
   - IBM DB2中的默认隔离级别。
2. SNAPSHOT ISOLATION
   - 保证在事务中进行的所有读操作都能看到事务启动时存在的数据库的一致快照。
   - 只有当事务的写操作不与快照之后的并发更新发生冲突时，事务才会提交。
   - 易受写入倾斜异常影响。


 

 
 
 
 
# 
 
 
 
