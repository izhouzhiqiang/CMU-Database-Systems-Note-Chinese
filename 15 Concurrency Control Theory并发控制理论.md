# Motivation 目的
- 丢失更新问题（并发控制）：同时更新记录时如何避免竞争条件？ 
- 持久性性问题（恢复）：如何保证断电时的正确状态？
# Transactions 事务
事务是在共享数据库上执行一系列一个或多个操作（例如 SQL 查询）以执行某些更高级别的功能。它们是 DBMS 中更改的基本单位。不允许部分事务（即事务必须是原子的）。
示例：将 100 美元从 Andy 的银行账户转入其发起人的账户 

1. 检查 Andy 是否有 100 美元。
2. 从他的账户中扣除 100 美元。
3. 将 100 美元添加到其发起人的帐户中。

要么需要完成所有步骤，要么都不完成任何步骤。
## The Strawman System
处理事务的一种简单系统是使用单个工作线程（例如一个线程）一次执行一个事务。因此，一次只能运行一个事务。为了执行事务，DBMS 复制整个数据库文件并对这个新文件进行事务更改。如果事务成功，则新文件将成为当前数据库文件。如果事务失败，DBMS 会丢弃新文件，并且不会保存事务的任何更改。此方法速度很慢，因为它不允许并发事务并且需要为每个事务复制整个数据库文件。
一个（可能）更好的方法是允许独立事务的并发执行，同时保持正确性和公平性（因为所有事务都以同等优先级处理，并且不会因从未执行而“饥饿”）。但在 DBMS 中执行并发事务具有挑战性。很难确保正确性（例如，如果 Andy 只有 100 美元并试图同时支付给两个发起人，谁应该得到报酬？）同时又快速执行交易（我们的示例保证了顺序正确性，但以并行性为代价） ）。
操作的任意交错可能导致： 

- 暂时不一致：不可避免，但不是问题。
- 永久不一致：不可接受，会导致数据正确性和完整性出现问题。

事务的范围仅在数据库内部。它无法对外部世界做出改变，因为它无法回滚这些改变。例如，如果事务导致发送电子邮件，则在事务中止时 DBMS 无法回滚电子邮件。
# Definitions
形式上，数据库可以表示为一组固定的命名数据对象（A、B、C……）。这些对象可以是属性、元组、页面、表甚至数据库。我们将讨论的算法适用于任何类型的对象，但所有对象必须属于同一类型。
事务是对这些对象的一系列读写操作（即 R(A)、W(B)）。为了简化讨论，这个定义假设数据库是固定大小的，因此只能进行读取和更新操作，而不能进行插入或删除操作。
交易的边界由客户端定义。在 SQL 中，事务以 BEGIN 命令开始。事务的结果是 COMMIT 或 ABORT。对于 COMMIT，要么所有事务的修改都保存到数据库中，要么 DBMS 覆盖它并中止。
对于 ABORT，事务的所有更改都将被撤消，就像事务从未发生过一样。
中止可能是自己造成的，也可能是由 DBMS 引起的。
用于确保数据库正确性的标准由缩写 ACID 给出。

- 原子性：原子性确保事务中的所有操作要么发生，要么什么都不发生。
- 一致性：如果每个事务都是一致的，并且数据库在事务开始时是一致的，那么在事务完成时数据库也能保证是一致的。如果数据满足所有验证规则（例如约束、级联和触发器），则数据是一致的。
- 隔离性：隔离性是指当一个事务执行时，它应该有一种与其他事务隔离的错觉。隔离性确保事务的并发执行应具有与事务的顺序执行相同的结果数据库状态。
- 持久性：如果事务提交，那么它对数据库的影响应该持续存在。

## ACID: Atomicity 原子性
DBMS 保证事务是原子的。事务要么执行其所有操作，要么不执行任何操作。有两种方法可以实现此目的：

- 方法#1：记录 DBMS 记录所有操作，以便在事务中止时可以撤消这些操作。它在内存和磁盘上维护撤消记录。出于审计和效率原因，几乎所有现代系统都使用日志记录。
- 方法#2：影子分页 DBMS 制作由事务修改的页面的副本，并且事务对这些副本进行更改。仅当事务提交时，页面才可见。这种方法在运行时通常比基于日志记录的 DBMS 慢。然而，一个好处是，如果您只是单线程，则不需要日志记录，因此当事务修改数据库时，对磁盘的写入会减少。这也使恢复变得简单，因为您所需要做的就是删除未提交事务中的所有页面。但一般来说，更好的运行时性能优于更好的恢复性能，因此在实践中很少使用。
## ACID: Consistency 一致性
从高层次上来说，一致性意味着数据库所代表的“世界”在逻辑上是正确的。应用程序询问的有关数据的所有问题（即查询）都将返回逻辑上正确的结果。一致性有两个概念：
数据库一致性：数据库准确地表示其正在建模的现实世界实体并遵循完整性约束。 （例如，一个人的年龄不能为负）。此外，未来的事务应该看到过去在数据库内提交的事务的影响。
事务一致性：如果数据库在事务开始之前是一致的，那么在事务开始之后数据库也将是一致的。确保事务一致性是应用程序的责任。
## ACID: Isolation 隔离性
DBMS 为事务提供了它们在系统中单独运行的错觉。他们看不到并发事务的影响。这相当于一个交易按串行顺序执行的系统（即一次一个）。但为了获得更好的性能，DBMS 必须交错并发事务的操作，同时保持隔离的假象。
### Concurrency Control
并发控制协议是 DBMS 在运行时决定多个事务操作的正确交错的方式。
并发控制协议有两类：

1.  悲观：DBMS 假设事务会发生冲突，因此它首先不会让问题出现。 
2.  乐观：DBMS 假设事务之间很少发生冲突，因此选择在事务提交后发生冲突时进行处理。 

DBMS 执行操作的顺序称为执行计划。我们希望交错事务以最大化并发性，同时确保输出“正确”。并发控制协议的目标是生成相当于某些串行执行的执行计划：

- 串行调度：不交错不同事务的操作的调度。
- 等效调度：对于任何数据库状态，如果执行第一个调度的效果与执行第二个调度的效果相同，则两个调度是等效的。
- 可序列化计划：可序列化计划是相当于事务的任何串行执行的计划。不同的串行执行可能会产生不同的结果，但都被认为是“正确的”。

如果两个操作针对不同的事务、在同一对象上执行并且至少其中一个操作是写入，则两个操作之间会发生冲突。冲突有三种变化：

- 读写冲突（“不可重复读取”）：事务多次读取同一对象时无法获得相同的值。
- 写-读冲突（“脏读”）：事务在提交其更改之前看到另一个事务的写效果。
- 写-写冲突（“丢失更新”）：一个事务覆盖另一个并发事务的未提交数据。

可串行化有两种类型：（1）冲突和（2）视图。这两种定义都不允许所有被认为可序列化的调度。实际上，DBMS 支持冲突可串行化，因为它可以有效地强制执行。
### Conflict Serializability 冲突串行化
两个调度是冲突等价的，当且仅当它们涉及相同事务的相同操作，并且每对冲突操作在两个调度中以相同的方式排序。如果调度 S 与某个串行调度冲突等价，则该调度 S 是可冲突串行化的。
我们可以通过交换非冲突操作直到形成串行调度来验证调度是否可冲突串行化。对于有很多交易的计划来说，这变得太昂贵了。验证调度的更好方法是使用依赖图（优先图）。
在依赖图中，每个事务都是图中的一个节点。存在从节点Ti到Tj的有向边，当且仅当来自Ti的操作Oi与来自Tj的操作Oj冲突并且Oi在调度中发生在Oj之前。然后，当且仅当依赖图是非循环时，调度是可冲突序列化的。
### View Serializability 查看串行化
视图可序列化性是可序列化性的较弱概念，它允许所有可冲突序列化和“盲写”的调度（即在不首先读取值的情况下执行写入）。因此，它允许比冲突可串行化更多的调度，但难以有效实施。这是因为 DBMS 不知道应用程序将如何“解释”值。因此，视图可串行性在实践中并不经常使用。
关于“盲写”：从数据库的角度来看，重要的是数据库状态是否相当于某种串行执行，因此如果最后一个操作是盲写，盲写仍然可以使一组事务视图可序列化
### Universe of Schedules
SerialSchedules ⊂ ConflictSerializableSchedules ⊂ V iewSerializableSchedules ⊂ AllSchedules
## ACID: Durability 持久性
在崩溃或重新启动后，已提交事务的所有更改都必须是持久的（即持久的）。
DBMS 可以使用日志记录或影子分页来确保所有更改都是持久的。这通常要求已提交的事务存储在非易失性存储器中。

 
 

 

 
