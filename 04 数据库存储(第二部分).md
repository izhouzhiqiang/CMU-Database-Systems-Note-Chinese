# Log-Structured 存储
与Slotted-Page设计相关的一些问题是:

- 碎片化:删除元组会在页面中留下空白，使它们没有得到充分利用。
- 无用的磁盘I/O:由于非易失性存储面向块的特性，需要获取整个块来更新元组。
- 随机磁盘I/O:磁盘读取器可能必须跳转到20个不同的位置来更新20个不同的元组，这可能非常慢。

如果我们在一个只允许创建新页面而不允许覆盖的系统上工作呢?日志结构存储模型适用于这种假设，并解决了上面列出的一些问题。

## 日志结构化存储
DBMS不存储元组，而是存储元组更改的日志记录。DBMS将新的日志条目附加到内存缓冲区中，而不检查以前的记录，然后将更改顺序写入磁盘。

- 记录包含元组的唯一标识符，操作类型(PUT/DELETE)，以及对于PUT操作，元组的内容。
- 为了读取一条记录，DBMS从最新到最旧的顺序扫描日志文件，以找到元组中最近的内容。
- 写速度快，读速度可能慢。磁盘写入是顺序的，现有页面是不可变的，这导致减少随机磁盘I/O。适用于仅追加存储。
- 为了避免长时间的读取，DBMS可以有索引来允许它跳转到日志中的特定位置。
- 日志最终会变得相当大。DBMS可以定期压缩日志，在多个页面上只获取每个元组最近的更改。
- 压缩后，不再需要排序，因为每个元组只有一个，因此DBMS可以按id排序以加快查找速度。这些被称为排序字符串表(sstable)。
- 在通用压缩中，任何日志文件都可以压缩在一起。在级别压缩中，最小的文件是级别0。0级文件可以被压缩成更大的1级文件，1级文件可以被压缩成2级文件，等等。
- 缺点是压缩成本高，并且还会导致写入放大(对于每个逻辑写入，可能会有多个物理写入)。
# Index-Organized 存储
注意，面向页面的存储和日志结构的存储都依赖于额外的索引来查找单个元组，因为表本身是无序的。在索引组织的存储方案中，DBMS直接将表的元组存储为索引数据结构的值。DBMS将使用看起来像槽页的页面布局，元组通常根据键在页面中排序。

# 数据表示
元组中的数据本质上只是字节数组，并且不跟踪属性的值类型。这取决于DBMS知道如何跟踪和解释这些字节。数据表示方案是DBMS存储值的字节的方式。
dbms希望确保元组是字对齐的，这样CPU就可以在没有任何意外行为或额外工作的情况下访问它。通常采用两种方法:

- 填充:在属性后添加空位以确保元组对齐。
- 重新排序:在物理布局中切换属性的顺序，以确保它们对齐。

元组中可以存储五种高级数据类型:整数、可变精度数、定点精度数、可变长度值和日期/时间。

## 整数

大多数dbms使用IEEE-754标准指定的C/ c++类型存储整数。这些值是固定长度的。
例如:INTEGER, BIGINT, SMALLINT, TINYINT。
## 浮点数
这些是使用IEEE-754标准指定的“本机”C/ c++类型的不精确的可变精度数字类型。这些值也是固定长度的。
对可变精度数的运算比任意精度数的运算要快，因为CPU可以直接在可变精度数上执行指令。但是，由于某些数字无法精确表示，因此在执行计算时可能会出现舍入误差。
例子:FLOAT, REAL。
## 定点数
这些是具有任意精度和比例的数字数据类型。它们通常以精确的可变长度二进制表示(几乎像字符串一样)存储，并带有额外的元数据，这些元数据将告诉系统数据的长度和小数应该在哪里。
这些数据类型在舍入误差不可接受的情况下使用，但是DBMS要付出性能损失才能获得这种精度。
例如:数字，十进制。
## 变长数据
这些表示任意长度的数据类型。它们通常与跟踪字符串长度的头一起存储，以便于跳转到下一个值。它还可能包含数据的校验和。
大多数dbms不允许元组超过单个页面的大小。那些将数据存储在一个特殊的“溢出”页上，并让元组包含对该页的引用。这些溢出页可以包含指向其他溢出页的指针，直到可以存储所有数据。
有些系统允许您将这些大值存储在外部文件中，然后元组将包含指向该文件的指针。例如，如果数据库存储照片信息，DBMS可以将照片存储在外部文件中，而不是让它们占用DBMS中的大量空间。这样做的一个缺点是DBMS不能操作该文件的内容。因此，没有持久性或事务保护。
示例:VARCHAR, VARBINARY, TEXT, BLOB。
##日期和时间
日期/时间的表示在不同的系统中有所不同。通常，这些时间表示为自unix纪元以来的某个单位时间(微/毫秒)秒。
例子:TIME, DATE, TIMESTAMP.
## 空数据类型
在DBMS中有三种表示null的常用方法。

- 空列位图标头:将位图存储在一个集中的标头中，指定哪些属性为空。这是最常见的方法。
- 特殊值:指定一个值来表示NULL数据类型(例如INT32_MIN)。
- 每个属性空标记:存储标记值为空的标记。不推荐使用这种方法，因为它不节省内存。对于每个值，DBMS必须使用不止一个位来避免弄乱单词对齐。

# 系统目录（系统表）
为了使DBMS能够解码元组的内容，它维护一个内部目录来告诉它关于数据库的元数据。

- 数据库的表和列，以及这些表上的索引。
- 数据库的用户及其权限。
- 关于表的统计信息以及表中包含的内容(即，属性的最大值)。

大多数dbms都按照表的格式将目录存储在自己内部。它们使用特殊的代码来“bootstrap”这些编目表，不需要DBA去主动维护。
