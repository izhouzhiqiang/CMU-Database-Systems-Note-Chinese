#  Transaction Locks 事务锁
到目前为止，我们对可串行化的概念都假设我们在构建计划时知道所有的读取和写入，但我们需要一种方法来保证实时的正确性。DBMS 使用锁来动态生成可串行化的事务执行计划。当有多个读取器和写入器时，这些锁会在并发访问期间保护数据库对象。DBMS 包含一个集中式锁管理器，它决定事务是否可以获取锁。 重要的是，锁不同于闩锁，例如 B+ 树抓取算法中使用的闩锁。闩锁保护 DBMS 的内部数据结构免受并发线程的影响，而锁保护数据库中的值免受并发事务的影响。例如，在 B+ 树中，您只需在扫描中对单个叶节点持有闩锁，因为这就是确保正确性所需要做的一切，但如果一个事务尝试叶扫描，而另一个事务尝试写入两个任意值，则叶扫描需要锁定整个表，而不仅仅是当前叶，以避免只看到两个写入中的一个。 锁有两种基本类型：

- 共享锁（S-LOCK）：共享锁允许多个事务同时读取同一个对象。如果一个事务持有共享锁，则另一个事务也可以获得相同的共享锁。
- 排它锁(X-LOCK)：排它锁允许事务修改对象。此锁可防止其他事务在对象上获取任何其他锁（S-LOCK 或 X-LOCK）。一次只有一个事务可以持有排他锁

事务必须向锁管理器请求锁（或升级）。锁管理器根据其他事务当前持有的锁来授予或阻止请求。当事务不再需要锁来释放对象时，必须释放锁。锁管理器使用有关哪些事务持有哪些锁以及哪些事务正在等待获取锁的信息来更新其内部锁表。
DBMS 的锁表不需要持久，因为当 DBMS 崩溃时任何活动的（即仍在运行的）事务都会自动中止。
然而，仅靠锁是不够的。锁需要由并发控制协议来补充，以确保以满足正确性保证的方式使用锁。
# Two-Phase Locking
两阶段锁定 (2PL) 是一种悲观并发控制协议，它使用锁来确定是否允许事务动态访问数据库中的对象。该协议不需要提前知道事务将执行的所有查询。
第 1 阶段 – 增长：在增长阶段，每个事务都向 DBMS 的锁管理器请求所需的锁。锁管理器授予/拒绝这些锁请求。
阶段 #2 – 收缩：事务在释放第一个锁后立即进入收缩阶段。在收缩阶段，只允许事务释放锁。他们不允许请求新的锁。
就其本身而言，2PL 足以保证冲突可串行化。它生成优先级图是非循环的调度。但它很容易出现级联中止，即一个事务中止，然后必须回滚另一个事务，这会导致工作浪费。
2PL 仍然可能存在脏读，并且还可能导致死锁。还有一些潜在的计划是可序列化的，但 2PL 不允许（锁定会限制并发性）。
## Strong Strict Two-Phase Locking	强两阶段锁
如果一个事务写入的任何值在第一个事务提交之前不会被另一个事务读取或覆盖，则调度是严格的。强严格 2PL（也称为严格 2PL）是 2PL 的一种变体，其中事务仅在提交时释放锁。
这种方法的优点是 DBMS 不会导致级联中止。 DBMS 还可以通过恢复已修改元组的原始值来反转中止事务的更改。然而，严格的 2PL 会生成更加谨慎/悲观的计划，从而限制并发性。
## Universe of Schedules
SerialSchedules ⊂ StrongStrict2PL ⊂ ConflictSerializableSchedules
⊂ ViewSerializableSchedules ⊂ AllSchedules
# Deadlock Handling
死锁是事务等待彼此释放锁的循环。 2PL 中有两种处理死锁的方法：检测和预防 
## Approach #1: Deadlock Detection 死锁检测 
为了检测死锁，DBMS 创建一个等待图，其中事务是节点，如果事务 Ti 正在等待事务 Tj 释放锁，则存在从 Ti 到 Tj 的有向边。系统将定期检查等待图中的循环（通常使用后台线程），然后决定如何打破它。构造图时不需要锁存器，因为如果 DBMS 在一次传递中错过了死锁，它将在后续传递中找到它。请注意，死锁检查的频率（使用 CPU 周期）和死锁被打破的等待时间之间存在权衡。
当 DBMS 检测到死锁时，它将选择一个“受害者”事务来中止以打破循环。受害者事务将重新启动或中止，具体取决于应用程序调用它的方式。 DBMS 在选择受害者打破死锁时可以考虑多个事务属性：

1.  按时间（最新或最旧的时间戳）。 
2.  按进度（执行的最少/最多查询）。 
3.  按已锁定的项目数量。 
4.  根据需要回滚的事务数量。 
5.  过去重新启动事务的次数（以避免饥饿）。 

没有一种选择比其他选择更好。许多系统结合使用这些因素。
选择要中止的受害者事务后，DBMS 还可以决定回滚事务更改的程度。它可以回滚整个事务，也可以回滚足够的查询来打破死锁。
## 
 Approach #2: Deadlock Prevention死锁预防
2PL 不会让事务尝试获取所需的任何锁，然后再处理死锁，而是在死锁发生之前阻止事务导致死锁。当一个事务尝试获取另一个事务持有的锁（这可能会导致死锁）时，DBMS 可以终止其中一个事务。为了实现这一点，事务被分配优先级（可能基于时间戳，较旧的事务具有较高的优先级）。这些方案保证不会发生死锁，因为在等待锁时只允许一种方向。当事务重新启动时，DBMS 会重用相同的时间戳。 在死锁预防下有两种方法可以终止事务：

- 等待死亡（“旧事务等待新事务”）：如果请求事务的优先级高于持有事务，则等待。否则，它会中止（死亡）。 
- 受伤等待（“新事务等待旧事务”）：如果请求事务的优先级高于持有事务，则持有事务中止（受伤）并释放锁。否则，请求事务将等待。
# Lock Granularities 锁粒度
如果一个事务想要更新 10 亿个元组，它必须向 DBMS 的锁管理器请求 10 亿个锁。这会很慢，因为事务在获取/释放锁时必须在锁管理器的内部锁表数据结构中获取锁存器。
或者，如果事务在只需要读取一个值时锁定整个表，则并行性的机会就会减少。为了处理这种权衡，DBMS 使用锁层次结构来同时处理不同粒度级别的锁。例如，它可以获取具有十亿个元组的表上的单个锁，而不是十亿个单独的锁。
当事务获取此层次结构中某个对象的锁时，它会隐式获取其所有子对象的锁，因此单写锁无法获取任何元组锁。但是，如果表上没有持有锁，则允许在不同的元组上使用多个元组级别的锁，从而允许并行性。
## 数据库锁层次结构：

1. 数据库级别（稍微罕见） 
2. 表级别（非常常见）
3. 页级别（常见）
4. 元组级别（非常常见）
5. 属性级别（罕见）

重要的是，如果事务使用元组级锁，则它需要传达其他事务无法获取页级锁（或任何更高级别的锁）的信息，因为这会发生冲突。为了实现这一点，意向锁是隐式锁，它发出信号表明较低级别持有显式锁。

- 意向共享(IS)：表示使用共享锁在较低级别进行显式锁定。
- 意向独占(IX)：表示在较低级别使用独占或共享锁进行显式锁定。
- 共享+意图独占 (SIX)：以该节点为根的子树被显式锁定在共享模式，显式锁定是在较低级别使用独占模式锁完成的
 
