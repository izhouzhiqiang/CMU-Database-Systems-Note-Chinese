# Isolation Levels 隔离级别
可序列化性很有用，因为它允许程序员忽略并发性问题，但强制执行它可能会导致并行性过低并限制性能。我们可能希望使用较弱的一致性级别来提高可伸缩性。
隔离级别控制事务暴露给其他并发事务操作的程度。
## 异常现象：

- Dirty Read:读取未提交的数据。
- Unrepeatable Reads:重读会得到不同的结果。
- 幻取:插入或删除导致相同范围扫描查询的不同结果。
## 隔离级别(从最强到最弱):

1. SERIALIZABLE:没有幻影，所有读取都是可重复的，没有脏读取。
   - 可能实现:索引锁+严格2PL。
2. 可重复读取:幽灵可能会发生。
   - 可能实施:严格的2PL。
3. READ-COMMITTED:可能会出现幻象和不可重复的读取。
   - 可能实现:对排他锁实行严格的2PL，读取后立即释放共享锁。
4. READ-UNCOMMITTED:所有异常都可能发生。
   - 可能的实现:对排他锁实行严格的2PL，对读不实行共享锁。

作为SQL-92标准的一部分定义的隔离级别只关注可能发生在基于2pl的DBMS中的异常情况。还有两个额外的隔离级别:

1. 在可重复读和已提交读之间。
   - 防止丢失的更新异常。
   - IBM DB2中的默认隔离级别。
2. SNAPSHOT ISOLATION
   - 保证在事务中进行的所有读操作都能看到事务启动时存在的数据库的一致快照。
   - 只有当事务的写操作不与快照之后的并发更新发生冲突时，事务才会提交。
   - 易受写入倾斜异常影响。
# Multi-Version Concurrency Control
多版本并发控制(MVCC)是一个比并发控制协议更大的概念。
它涉及DBMS的设计和实现的所有方面。MVCC是dbms中使用最广泛的方案。在过去的10年里，它几乎被用于每一个新的DBMS。甚至一些不支持多语句事务的系统(例如NoSQL)也使用它。
使用MVCC, DBMS在数据库中维护单个逻辑对象的多个物理版本。
当事务写入对象时，DBMS创建该对象的新版本。当事务读取对象时，它将读取事务开始时存在的最新版本。
MVCC的基本概念/好处是，写入器不会阻塞读取器，读取器也不会阻塞写入器。这意味着当其他事务读取旧版本时，一个事务可以修改对象。
如果写同一个对象，写程序可能仍然会阻塞其他写程序，因为与数据库对象相关的版本仍然存在锁。
使用MVCC的一个优点是，只读事务可以在不使用任何锁的情况下读取数据库的一致快照。此外，多版本的dbms可以很容易地支持时间旅行查询，这是基于数据库在其他时间点的状态的查询(例如，在数据库上执行3小时前的查询)。
一个典型的基于mvc的数据库设计将:

1.  有一个版本存储，用于存储同一逻辑对象的不同版本。 
2.  当事务开始时，DBMS获取数据库的快照(通过复制事务状态表)。 
3.  DBMS使用快照来确定哪些版本的对象对事务可见。

有五个重要的MVCC设计决策:

1. 并发控制协议
2. 版本存储
3. 垃圾收集
4. 索引管理
5. 删除

并发协议的选择是在前面讲座中讨论的方法(两阶段锁定、时间戳排序、乐观并发控制)之间进行的。

## Snapshot Isolation 快照隔离
快照隔离涉及在事务启动时为事务提供数据库的一致快照。快照中的数据值仅由提交的事务的值组成，并且事务在完成之前与其他事务完全隔离。这对于只读事务来说是理想的，因为它们不需要等待来自其他事务的写。写操作在事务的私有工作区中维护，或者使用事务元数据写入存储，只有在事务成功提交后才对数据库可见
## Write Conflicts写冲突
如果两个事务更新同一个对象，则第一个写入者获胜。
## Write Skew Anomaly写偏异常
当两个并发事务修改不同的对象导致不可序列化的调度时，可能在快照隔离中发生。例如，如果一个事务将所有白色弹珠更改为黑色，而另一个事务将所有黑色弹珠更改为白色，则结果可能不对应于任何可序列化的调度。
# Version Storage
这就是DBMS如何存储逻辑对象的不同物理版本，以及事务如何找到对它们可见的最新版本。
DBMS使用元组的指针字段为每个逻辑元组创建一个版本链，它本质上是一个按时间戳排序的版本链表。这允许DBMS在运行时找到对特定事务可见的版本。索引总是指向链的“头”，根据实现的不同，它要么是最新的，要么是最旧的版本。线程遍历链，直到找到正确的版本。不同的存储方案决定了每个版本的存储位置和内容。

1. 方法#1:仅追加存储逻辑

元组的所有物理版本都存储在相同的表空间中。版本在表中混合在一起，每次更新只是将元组的新版本附加到表中并更新版本链。链可以从最老到最新(O2N)排序，这需要在查找时进行链遍历，也可以从最新到最老(N2O)排序，这需要为每个新版本更新索引指针。

2. 方法#2:时间线存储

DBMS维护一个单独的表，称为时间线表，用于存储旧版本的元组。每次更新时，DBMS都会将旧版本的元组复制到时间线表中，并用新数据覆盖主表中的元组。主表中的元组指针指向时间线表中的过去版本。

3. 方法#3:增量存储类

似于时间旅行存储，但不是整个过去的元组，DBMS只在所谓的增量存储段中存储增量或元组之间的更改。然后，事务可以通过以相反的顺序遍历增量并应用它们来重新创建旧版本。这导致写入速度比时间旅行存储快，但读取速度较慢。
# Garbage Collection垃圾收集
随着时间的推移，DBMS需要从数据库中删除可回收的物理版本。如果没有活动事务可以“看到”该版本，或者该版本是由终止的事务创建的，则该版本是可回收的
方法#1:元组级垃圾收集使用元组级垃圾收集，DBMS通过直接检查元组来查找旧版本。有两种方法可以实现这一点:

- Background Vacuuming:单独的线程定期扫描表并寻找可回收的版本。这适用于任何版本存储方案。一个简单的优化是维护一个“脏页位图”，它跟踪自上次扫描以来修改了哪些页面。这允许线程跳过未更改的页面。
- Cooperative Cleaning:工作线程在遍历版本链时识别可回收的版本。这只适用于O2N链。如果数据没有被访问，它将永远不会被清理。

方法#2:事务级垃圾收集在事务级垃圾收集中，每个事务负责跟踪它们自己的旧版本，因此DBMS不必扫描元组。每个事务维护自己的读/写集。当事务完成时，垃圾收集器可以使用它来确定要回收哪些元组。DBMS确定完成的事务创建的所有版本何时不再可见。
# Index Management
所有主键(pkey)索引总是指向版本链头。DBMS更新pkey索引的频率取决于当元组更新时系统是否创建了新版本。如果一个事务更新了一个pkey属性，那么它将被视为DELETE，然后是INSERT。
管理二级索引更为复杂。处理它们有两种方法。
方法#1:逻辑指针
DBMS对每个元组使用一个固定的标识符，这个标识符不会改变。这需要一个额外的间接层，将逻辑id映射到元组的物理位置。然后，对元组的更新只能更新间接层中的映射。
方法#2:物理指针
DBMS使用物理地址到版本链头。这需要在更新版本链头时更新每个索引，这可能非常昂贵。
MVCC DBMS索引(通常)不存储关于元组及其键的版本信息。相反，每个索引必须支持来自不同快照的重复键，因为相同的键可能指向不同快照中的不同逻辑元组。

当多个事务需要相同逻辑元组的多个版本时，MVCC重复键问题描述了在MVCC DBMS索引中支持重复键的需求。例如，假设txn1指向一个逻辑元组的版本0，而txn2创建同一个逻辑元组的版本1。我们的索引需要指向两个txn的这两个版本，这样每个事务在任何时候都可以访问正确的版本。
工作线程可能在一次读取中获得多个条目，然后它们必须遵循指针来找到它们正确的物理版本。

# Deletes
只有当逻辑删除的元组的所有版本都不可见时，DBMS才从数据库中物理删除元组。如果元组被删除，则在最新版本之后不能有该元组的新版本。这意味着没有写-写冲突，第一个写者获胜。
我们需要一种方法来表示元组在某个时间点已被逻辑删除。有两种方法可以解决这个问题。
方法#1:删除标志维护一个标志，表明逻辑元组在最新的物理版本之后已被删除。这可以在元组标题中，也可以在单独的列中。
方法#2:Tombstone Tuple创建一个空的物理版本，以指示逻辑元组被删除。为版本链指针中只有特殊位模式的墓碑元组使用单独的池，以减少存储开销。

 
